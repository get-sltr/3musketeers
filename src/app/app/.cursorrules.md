# SLTR - Cursor AI Rules
# "RULES DON'T APPLY" - Next-Generation Real-Time Social Platform

## Project Overview
SLTR is an enterprise-grade real-time social platform that revolutionizes how people connect, communicate, and build relationships. Combining real-time messaging, WebRTC video calling, file sharing, social discovery, and AI-powered features into one seamless experience. Built with modern infrastructure for millions of users.

## Core Technologies
- **Framework**: Next.js 14+ (App Router)
- **Database**: Supabase (PostgreSQL with real-time sync)
- **Backend Services**: Railway (scalable backend)
- **Authentication**: Supabase Auth with email verification
- **Real-Time**: Supabase Realtime + WebSockets
- **Video/Voice**: WebRTC (peer-to-peer calling)
- **Maps**: Mapbox GL JS (location-based features)
- **AI Integration**: Blaze AI powered by Perplexity
- **CDN/Hosting**: Vercel (global edge network)
- **Security**: Cloudflare (DDoS protection, WAF)
- **File Storage**: Supabase Storage with CDN
- **Styling**: Tailwind CSS with glassmorphism design
- **Domain**: getsltr.com

## Architecture Principles

### Code Organization
- Use App Router structure (`app/` directory)
- Separate concerns: components, utils, hooks, types
- Keep server and client components clearly separated
- Use `'use client'` directive only when necessary
- Place API routes in `app/api/` directory

### Component Structure
```
/app
  /components
    /ui              # Reusable UI components
    /messaging       # Chat/messaging components
    /video           # WebRTC video calling components
    /audio           # Voice calling components
    /groups          # Group chat management
    /files           # File sharing/upload components
    /ai              # Blaze AI integration components
    /social          # Social discovery components
    /maps            # Location-based features
    /profiles        # User profile components
    /migration       # Telegram migration tools
    /notifications   # Real-time notification system
  /api
    /messages        # Message CRUD operations
    /video           # Video call signaling
    /files           # File upload/download
    /ai              # Blaze AI endpoints
    /groups          # Group management
    /migration       # Telegram import APIs
    /matches         # Social discovery
  /(routes)          # Page routes
  /lib
    /supabase        # Supabase client utilities
    /webrtc          # WebRTC connection management
    /ai              # AI integration utilities
    /migration       # Migration logic
```

## Database & Supabase

### Row Level Security (RLS)
- ALWAYS implement RLS policies for every table
- Use authenticated user context: `auth.uid()`
- Default deny, explicit allow
- Test policies thoroughly before deployment

### Standard RLS Patterns
```sql
-- Read own profile
CREATE POLICY "Users can read own profile"
ON profiles FOR SELECT
USING (auth.uid() = id);

-- Update own profile
CREATE POLICY "Users can update own profile"
ON profiles FOR UPDATE
USING (auth.uid() = id);

-- Read public profiles (for matching)
CREATE POLICY "Users can read verified profiles"
ON profiles FOR SELECT
USING (is_verified = true AND is_active = true);
```

### Tables Structure
- `profiles`: User profiles with bio, interests, location, privacy settings
- `messages`: Real-time messaging with typing indicators, delivery status
- `conversations`: Direct message threads and metadata
- `groups`: Group chats with admin controls, permissions
- `group_members`: Group membership and roles
- `group_messages`: Group chat messages
- `video_calls`: Call history, duration, participants
- `files`: Shared files with metadata, thumbnails
- `matches`: Social discovery and mutual interests
- `reports`: Safety reporting system
- `blocks`: User blocking functionality
- `notifications`: Real-time notification delivery
- `ai_interactions`: Blaze AI conversation history
- `telegram_migrations`: Migration tracking and history
- `user_settings`: Privacy, notifications, preferences
- `typing_indicators`: Real-time typing status

### Supabase Client Usage
- Use singleton pattern for client initialization
- Server components: `createServerComponentClient`
- Client components: `createClientComponentClient`
- API routes: `createRouteHandlerClient`
- Never expose service role key on client side

## Authentication Flow

### Required Features
1. Email/password signup with verification
2. Email confirmation before app access
3. Profile completion required after verification
4. Session management with automatic refresh
5. Secure logout with cleanup

### Implementation Pattern
```typescript
// Check auth state
const { data: { session } } = await supabase.auth.getSession();

// Require verification
if (session && !session.user.email_confirmed_at) {
  redirect('/verify-email');
}

// Require profile completion
const { data: profile } = await supabase
  .from('profiles')
  .select('*')
  .eq('id', session.user.id)
  .single();

if (!profile.is_complete) {
  redirect('/complete-profile');
}
```

## WebRTC Implementation

### Setup Requirements
- Use `simple-peer` or native WebRTC APIs
- Implement STUN/TURN servers for NAT traversal
- Signaling server on Railway backend
- ICE candidate exchange via WebSocket
- Media stream management
- Connection state monitoring

### Video Call Flow
```typescript
// 1. Initiate call
const localStream = await navigator.mediaDevices.getUserMedia({
  video: true,
  audio: true
});

// 2. Create peer connection
const peer = new RTCPeerConnection(config);

// 3. Add local stream
localStream.getTracks().forEach(track => {
  peer.addTrack(track, localStream);
});

// 4. Exchange ICE candidates via signaling
peer.onicecandidate = (event) => {
  if (event.candidate) {
    sendToSignalingServer({
      type: 'ice-candidate',
      candidate: event.candidate
    });
  }
};

// 5. Handle remote stream
peer.ontrack = (event) => {
  remoteVideo.srcObject = event.streams[0];
};

// 6. Create and send offer/answer
const offer = await peer.createOffer();
await peer.setLocalDescription(offer);
sendToSignalingServer({ type: 'offer', sdp: offer });
```

### Call Features Implementation
- **Screen Sharing**: `getDisplayMedia()` API
- **Background Blur**: Canvas manipulation or ML models
- **Recording**: MediaRecorder API with user consent
- **Quality Adjustment**: Adaptive bitrate based on network
- **Noise Cancellation**: Audio processing nodes
- **Multiple Participants**: SFU (Selective Forwarding Unit) architecture

### Error Handling
- Camera/microphone permission denied
- Network connectivity issues
- Peer connection failures
- Browser compatibility checks
- Graceful degradation
- User feedback mechanisms

## Map Integration (Mapbox)

### Setup Requirements
- Store API key in environment variable: `NEXT_PUBLIC_MAPBOX_TOKEN`
- Use `mapbox-gl` package
- Implement custom markers for user locations
- Center map on user's current location
- Show DTFN status on map markers

### Map Component Pattern
```typescript
'use client';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';

// Initialize with user location
// Add custom markers for nearby users
// Implement click handlers for profile views
// Update markers on real-time location changes
// Show distance and compatibility scores
```

### Location Handling
- Request geolocation permission on first use
- Update location periodically when app is active
- Store location with privacy settings
- Implement location-based search radius
- Show distance in profiles
- Temporary location sharing in chats
- Location history (privacy-controlled)

## Blaze AI Integration (Powered by Perplexity)

### API Setup
```typescript
// Environment variables
PERPLEXITY_API_KEY=
BLAZE_AI_ENDPOINT=

// API client
import { PerplexityClient } from '@perplexity/sdk';

const blazeAI = new PerplexityClient({
  apiKey: process.env.PERPLEXITY_API_KEY
});
```

### AI Features Implementation

#### Smart Conversations
```typescript
// AI-powered chat assistance
const generateReply = async (context: string, message: string) => {
  const response = await blazeAI.chat.completions.create({
    model: 'sonar-pro',
    messages: [
      { role: 'system', content: 'You are a helpful dating conversation assistant.' },
      { role: 'user', content: `Context: ${context}\nMessage: ${message}` }
    ]
  });
  
  return response.choices[0].message.content;
};
```

#### Profile Optimization
- Analyze profile completeness
- Suggest bio improvements
- Recommend better photos
- Interest tag suggestions
- Compatibility insights

#### Content Moderation
- Real-time message scanning
- Inappropriate content detection
- Automated warning system
- Report prioritization
- Pattern recognition for harassment

#### Translation
- Real-time message translation
- Language detection
- Context-aware translations
- Preserve tone and meaning
- Support 100+ languages

#### Voice Transcription
- Speech-to-text for voice messages
- Real-time transcription in calls
- Multi-language support
- Timestamp synchronization
- Accessibility features

### AI Credits System
```typescript
// Track AI usage
interface AICredits {
  userId: string;
  creditsRemaining: number;
  tier: 'free' | 'premium' | 'enterprise';
  resetDate: Date;
}

// Free: 50 requests/month
// Premium: 500 requests/month
// Enterprise: Unlimited
```

### Branding Guidelines
- Always display "Blaze AI powered by Perplexity"
- Use Perplexity logo alongside Blaze AI branding
- Acknowledge AI assistance in features
- Link to Perplexity in settings/about
- Transparent AI usage indicators

## Telegram Migration System

### Migration Architecture
```typescript
// Migration workflow
interface TelegramMigration {
  userId: string;
  telegramUserId: string;
  status: 'pending' | 'in-progress' | 'completed' | 'failed';
  chatsToImport: string[];
  progress: number;
  startedAt: Date;
  completedAt?: Date;
}
```

### Import Process
1. **Authentication**: User logs into Telegram via OAuth
2. **Selection**: Choose chats/groups to import
3. **Authorization**: Request permissions for data access
4. **Migration**: Transfer data using official Telegram API
5. **Verification**: Confirm all data imported correctly
6. **Cleanup**: Option to delete Telegram account

### Data Transfer
```typescript
// Chat history import
const importTelegramChat = async (chatId: string) => {
  // Fetch messages from Telegram API
  const messages = await telegramAPI.getMessages(chatId);
  
  // Transform to SLTR format
  const sltrMessages = messages.map(transformMessage);
  
  // Bulk insert into Supabase
  await supabase.from('messages').insert(sltrMessages);
  
  // Update progress
  updateMigrationProgress(chatId);
};
```

### Group Migration
- Recreate group structure
- Preserve admin roles
- Import member list
- Transfer group settings
- Migrate group media
- Maintain message order
- Link original members

### Privacy Compliance
- User-initiated process only
- Clear consent dialogs
- Transparent data usage
- GDPR Article 20 (data portability)
- Secure API communication
- Delete migration data after completion
- Audit trail maintenance

## Styling & UI

### Design System
- Glassmorphism aesthetic throughout
- Color scheme: Vibrant gradients with dark theme
- Transparency effects: `backdrop-blur-md`
- Consistent spacing: Tailwind spacing scale
- Mobile-first responsive design

### Component Styling Pattern
```typescript
className="bg-white/10 backdrop-blur-md border border-white/20 rounded-xl"
```

### Key UI Elements
- **Chat Interface**: Messaging with typing indicators, reactions
- **Video Call UI**: In-call controls, participant grid, screen share
- **Group Management**: Admin panel, member list, settings
- **File Viewer**: Image/video preview, document viewer
- **Navigation**: Bottom tab bar (mobile), sidebar (desktop)
- **Notifications**: Toast notifications, badge counters
- **AI Assistant**: Blaze AI chat interface, suggestions panel
- **Migration Wizard**: Step-by-step import process
- **Profile Cards**: Swipeable cards for social discovery
- **Settings Dashboard**: Comprehensive privacy and preference controls
- **Loading States**: Skeleton screens, progress indicators
- **Modals**: Confirmation dialogs, forms, media viewers

## Platform Features

### 🔥 Core Communication Features

#### Real-Time Messaging
- Direct messages with instant delivery
- Group chats with unlimited members
- Live typing indicators
- Read receipts and delivery status
- Message reactions and emoji support
- Rich text formatting
- Link previews
- Message editing and deletion
- Reply/quote functionality
- Message search

#### WebRTC Video Calling
- Peer-to-peer video calls
- Crystal-clear HD quality
- Screen sharing capability
- Multiple participants support
- Call recording (with consent)
- Background blur/virtual backgrounds
- Network quality indicators
- Automatic reconnection
- Mobile and desktop support

#### Voice Calling
- High-quality audio calls
- Low latency communication
- Noise cancellation
- Echo suppression
- Multiple participants
- Call history tracking

#### File Sharing
- Drag-and-drop upload
- Multiple file types support
- Image/video thumbnails
- File preview in-app
- Progress indicators
- Resume interrupted uploads
- File size limits by tier
- Virus scanning
- CDN-delivered downloads

### 🤖 AI-Powered Features (Blaze AI)

#### Conversation Assistance
- Smart reply suggestions
- Conversation starters
- Tone adjustment
- Grammar correction
- Message translation (real-time)
- Context-aware responses

#### Profile Optimization
- Bio writing assistance
- Interest recommendations
- Photo suggestions
- Profile completeness scoring
- Compatibility analysis

#### Content Moderation
- Inappropriate content detection
- Spam filtering
- Automated warnings
- Report prioritization
- Threat assessment

#### Smart Features
- Priority notifications (AI-ranked)
- Personalized recommendations
- Group suggestions
- Event discovery
- Interest matching
- Voice-to-text transcription

### 🌍 Social Discovery

#### Location-Based Matching
- Proximity-based discovery
- Radius customization
- Real-time location updates
- Privacy controls
- Distance display
- Location sharing (temporary)

#### Profile Features
- Photo galleries
- Video introductions
- Interest tags/categories
- Bio with rich text
- Social links
- Verification badges
- Activity status
- Last seen timestamps

#### Matching System
- Swipe mechanics
- Mutual interest notifications
- Compatibility scores (AI-powered)
- Icebreaker suggestions
- Match expiration options

### 👥 Group Features

#### Group Management
- Create public/private groups
- Group descriptions and rules
- Custom group icons
- Member roles (admin, moderator, member)
- Invite links
- Join requests approval
- Member limits by tier
- Group search/discovery

#### Group Communication
- Group messaging
- @mentions
- Announcements channel
- Pinned messages
- Polls and surveys
- File sharing
- Group video calls
- Scheduled events

#### Moderation Tools
- Admin controls
- Kick/ban members
- Message deletion
- Slow mode
- Content filters
- Report management
- Auto-moderation (AI)

### 🔄 Telegram Migration

#### One-Click Import
- "Import from Telegram" button
- 30-second migration process
- Chat history transfer
- Group recreation
- Media import
- Contact discovery
- Settings sync
- Zero data loss

#### Migration Features
- Select specific chats to import
- Date range selection
- Media quality options
- Progress tracking
- Rollback capability
- Export original data
- Migration history

#### Legal Compliance
- User-initiated only
- Transparent process
- Official API usage
- GDPR/CCPA compliant
- Data encryption in transit
- User consent required

### 🔒 Privacy & Security

#### User Controls
- Granular privacy settings
- Block/report users
- Hidden profile mode
- Last seen controls
- Read receipt toggles
- Profile visibility settings
- Location sharing controls
- Data export tools
- Account deletion

#### Platform Security
- End-to-end encryption (messages)
- Two-factor authentication
- Session management
- Device tracking
- Login alerts
- Suspicious activity detection
- Cloudflare DDoS protection
- WAF (Web Application Firewall)
- Regular security audits

### 💎 Premium Features (Monetization)

#### Free Tier
- Basic messaging (unlimited)
- Group chats (up to 100 members)
- Video calls (1-on-1, 30min limit)
- File sharing (25MB limit)
- Basic AI features (limited)
- Standard support

#### Premium Tier ($9.99/month)
- Unlimited video calls
- HD video quality
- File sharing (500MB limit)
- Advanced AI features
- Custom themes
- Priority support
- No ads
- Verified badge
- Advanced privacy controls
- Group admin tools

#### Enterprise Tier (Custom pricing)
- White-label solution
- Custom branding
- API access
- SSO integration
- Admin dashboard
- Analytics tools
- Dedicated support
- SLA guarantees
- Custom integrations
- Data residency options

## Security Best Practices

### Environment Variables
```
# Supabase
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=              # Server-side only

# Mapbox
NEXT_PUBLIC_MAPBOX_TOKEN=

# Perplexity AI (Blaze AI)
PERPLEXITY_API_KEY=                     # Server-side only
BLAZE_AI_ENDPOINT=

# Railway Backend
RAILWAY_API_URL=
RAILWAY_API_KEY=

# Cloudflare
CLOUDFLARE_ZONE_ID=
CLOUDFLARE_API_KEY=

# WebRTC
TURN_SERVER_URL=
TURN_USERNAME=
TURN_CREDENTIAL=
STUN_SERVER_URL=

# Telegram Migration
TELEGRAM_API_ID=
TELEGRAM_API_HASH=

# Stripe (Payments)
STRIPE_PUBLIC_KEY=
STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=

# General
NEXT_PUBLIC_APP_URL=https://getsltr.com
NODE_ENV=production
```

### Data Validation & Input Security
```typescript
import { z } from 'zod';

// Validate all inputs
const messageSchema = z.object({
  content: z.string().min(1).max(5000),
  conversationId: z.string().uuid(),
  attachments: z.array(z.string().url()).max(10).optional()
});

// Sanitize user content
import DOMPurify from 'isomorphic-dompurify';
const sanitized = DOMPurify.sanitize(userInput);
```

### API Security
- Rate limiting per endpoint
  ```typescript
  // 100 requests per minute per user
  const rateLimiter = new RateLimit({
    windowMs: 60 * 1000,
    max: 100,
    keyGenerator: (req) => req.user.id
  });
  ```
- API key rotation schedule
- Request signing for sensitive operations
- CSRF protection
- SQL injection prevention (parameterized queries)
- NoSQL injection prevention
- API versioning

### File Upload Security
- Virus scanning on upload (ClamAV)
- File type validation (whitelist only)
- File size limits by tier
- Filename sanitization
- Content-type validation
- Scan for malicious scripts
- Quarantine suspicious files
- Image metadata stripping

### Authentication & Authorization
- Multi-factor authentication (2FA)
- Session management with refresh tokens
- Device tracking and management
- Suspicious login detection
- IP-based rate limiting
- JWT validation on every request
- Secure password requirements (12+ chars, complexity)
- Account recovery flows
- Biometric authentication (mobile)

### Data Encryption
- End-to-end encryption for messages
- Encrypted file storage at rest
- PII data encryption
- HTTPS everywhere (enforce)
- Secure WebSocket connections (WSS)
- TLS 1.3 minimum
- Certificate pinning (mobile)

### Security Headers
```typescript
// Next.js security headers
const securityHeaders = [
  { key: 'X-DNS-Prefetch-Control', value: 'on' },
  { key: 'Strict-Transport-Security', value: 'max-age=63072000; includeSubDomains; preload' },
  { key: 'X-Frame-Options', value: 'SAMEORIGIN' },
  { key: 'X-Content-Type-Options', value: 'nosniff' },
  { key: 'Referrer-Policy', value: 'origin-when-cross-origin' },
  { key: 'Permissions-Policy', value: 'camera=(), microphone=(), geolocation=()' }
];
```

### Cloudflare Security
- DDoS protection (automatic)
- Web Application Firewall (WAF)
- Bot management and challenge pages
- Rate limiting at edge
- SSL/TLS encryption
- DNSSEC
- IP reputation blocking

### Privacy Compliance
- **GDPR**: Data portability, right to deletion
- **CCPA**: Opt-out mechanisms, data disclosure
- **Age Verification**: 18+ required
- Clear privacy policy and terms
- User consent management
- Data retention policies (30 days for deleted)
- Audit logging
- Regular security audits
- Data processing agreements
- Cookie consent management

### Monitoring & Incident Response
- Failed login tracking (lock after 5 attempts)
- Unusual activity detection (AI-powered)
- API abuse monitoring
- Error tracking (Sentry)
- Performance monitoring (Vercel Analytics)
- Security incident response plan
- Automated alerting
- Penetration testing schedule
- Implement rate limiting on API routes
- Use Zod for schema validation
- Never trust client-side data

### Privacy Controls
- User consent for location sharing
- Granular privacy settings
- Data deletion capabilities
- GDPR compliance considerations

## Performance Optimization

### Image & Media Handling
- Use Next.js Image component with priority loading
- Implement lazy loading for galleries
- Compress images on upload (client-side)
- Generate thumbnails server-side
- Use Supabase Storage with CDN
- Serve optimized WebP format
- Progressive JPEG loading
- Video thumbnail generation
- Streaming for large files

### Data Fetching Strategies
- **Pagination**: Cursor-based for infinite scroll
- **Caching**: SWR for frequently accessed data
- **Prefetching**: Predictive loading for likely navigation
- **Debouncing**: Search and typing indicators
- **Throttling**: Location updates, scroll events
- **Optimistic Updates**: Immediate UI feedback
- **Background Sync**: Queue and sync offline actions

### Real-Time Optimization
- Limit active subscriptions (max 3-5 per page)
- Unsubscribe from channels on navigation
- Use broadcast for ephemeral data (typing)
- Use database changes for persistent data (messages)
- Batch updates when possible
- Throttle high-frequency events

### Code Splitting & Bundling
- Route-based code splitting (automatic)
- Dynamic imports for heavy components
  ```typescript
  const VideoCall = dynamic(() => import('@/components/video/VideoCall'), {
    ssr: false,
    loading: () => <VideoCallSkeleton />
  });
  ```
- Lazy load AI features
- Split vendor bundles appropriately
- Tree-shake unused dependencies
- Minimize bundle size (<200kb initial)

### CDN & Edge Optimization
- **Vercel Edge Functions**: Auth, API routes
- **Cloudflare**: Static assets, DDoS protection
- **Supabase CDN**: Database-driven content
- **Railway**: WebSocket connections, media processing
- Global edge network for low latency
- HTTP/3 and QUIC protocol support

### Database Optimization
- Index frequently queried columns
- Use database views for complex queries
- Implement full-text search with pg_trgm
- Materialize expensive aggregations
- Connection pooling (Supabase handles)
- Query optimization with EXPLAIN ANALYZE
- Avoid N+1 queries with joins

### Caching Strategy
```typescript
// Redis-like caching with Supabase
const getCachedProfile = async (userId: string) => {
  // Try cache first
  const cached = await getFromCache(`profile:${userId}`);
  if (cached && isFresh(cached)) return cached;
  
  // Fetch from database
  const profile = await fetchProfile(userId);
  
  // Store in cache
  await setCache(`profile:${userId}`, profile, { ttl: 300 });
  
  return profile;
};
```

### Mobile Optimization
- Reduce initial bundle size
- Lazy load non-critical features
- Optimize images for mobile networks
- Implement service worker for offline
- Use native APIs when available
- Touch-optimized interactions
- Reduce animation complexity on low-end devices

## Error Handling

### Standard Pattern
```typescript
try {
  const { data, error } = await supabase
    .from('table')
    .select();
  
  if (error) throw error;
  
  // Success handling
} catch (error) {
  console.error('Error:', error);
  // User-friendly error message
  toast.error('Something went wrong. Please try again.');
}
```

### User Feedback
- Toast notifications for actions
- Loading states for async operations
- Clear error messages (no technical jargon)
- Retry mechanisms for failed operations
- Offline state handling

## Testing Strategy

### Unit Testing
- Component testing with Jest + React Testing Library
- API route testing
- Utility function testing
- Custom hooks testing
- 80%+ code coverage target

### Integration Testing
- Authentication flows
- Real-time messaging
- Video call connections
- File upload/download
- Payment processing
- Migration workflows

### E2E Testing (Playwright/Cypress)
```typescript
// Critical user journeys
test('User can send and receive messages', async ({ page }) => {
  await page.goto('/messages');
  await page.fill('[data-testid="message-input"]', 'Hello!');
  await page.click('[data-testid="send-button"]');
  await expect(page.locator('[data-testid="message"]')).toContainText('Hello!');
});
```

### Critical Paths to Test
1. **Authentication**: Signup → Email verification → Profile completion → Login
2. **Messaging**: Send message → Delivery → Read receipt → Reply
3. **Video Calls**: Initiate → Connect → Stream → End call
4. **Groups**: Create → Invite → Message → Admin actions
5. **File Sharing**: Upload → Progress → Download → Preview
6. **Social Discovery**: Browse → Match → Chat
7. **Migration**: Connect Telegram → Select chats → Import → Verify
8. **Payments**: Select plan → Checkout → Success → Access features
9. **AI Features**: Request suggestion → Receive → Apply
10. **RLS Policies**: Unauthorized access attempts blocked

### Performance Testing
- Load testing (Artillery/k6)
- Stress testing for concurrent users
- WebRTC connection limits
- Real-time subscription limits
- Database query performance
- API response time benchmarks

### Security Testing
- Penetration testing (quarterly)
- Vulnerability scanning
- SQL injection attempts
- XSS attack vectors
- CSRF token validation
- Rate limit effectiveness
- Authentication bypass attempts

## Deployment Strategy

### Infrastructure
- **Frontend**: Vercel (edge network, automatic scaling)
- **Backend**: Railway (WebSocket, media processing)
- **Database**: Supabase (managed PostgreSQL)
- **CDN**: Cloudflare (static assets, security)
- **Domain**: getsltr.com (SSL/TLS via Cloudflare)

### Vercel Deployment
```bash
# Production deployment
vercel --prod

# Environment variables configured in Vercel dashboard
# Preview deployments for all PRs
# Automatic rollback on errors
```

### Railway Backend
- WebSocket server for video signaling
- Media processing workers
- Background job queues
- Cron jobs for cleanup tasks
- Horizontal scaling enabled

### Database Migrations
```bash
# Create migration
npx supabase migration new add_feature_table

# Apply migration
npx supabase db push

# Rollback if needed
npx supabase migration repair
```

### CI/CD Pipeline
```yaml
# GitHub Actions workflow
name: Deploy
on:
  push:
    branches: [main]
jobs:
  test:
    - Run tests
    - Run linting
    - Security scan
  deploy:
    - Build application
    - Deploy to Vercel
    - Run smoke tests
    - Notify team
```

### Pre-Deployment Checklist
- [ ] All tests passing (unit, integration, e2e)
- [ ] RLS policies tested and verified
- [ ] Environment variables configured
- [ ] API rate limits implemented
- [ ] Error boundaries in place
- [ ] Performance benchmarks met
- [ ] Mobile responsiveness verified
- [ ] Browser compatibility tested
- [ ] Email templates configured
- [ ] Terms of Service and Privacy Policy updated
- [ ] Monitoring and alerting configured
- [ ] Backup strategy verified
- [ ] Rollback plan documented
- [ ] Security audit completed
- [ ] Load testing passed

### Monitoring & Observability
- **Vercel Analytics**: Page views, performance
- **Sentry**: Error tracking and alerting
- **Supabase Dashboard**: Database metrics
- **Railway Logs**: Backend service logs
- **Cloudflare Analytics**: Traffic and security
- **Custom Dashboards**: Business metrics
- **Uptime Monitoring**: Pingdom or UptimeRobot
- **APM**: Application performance monitoring

### Backup & Disaster Recovery
- **Database**: Daily automated backups (Supabase)
- **Files**: Replicated across regions
- **Point-in-time Recovery**: 7-day retention
- **Disaster Recovery Plan**: RTO 4 hours, RPO 1 hour
- **Regular restore testing**: Monthly

### Scaling Strategy
- **Horizontal Scaling**: Auto-scale on Vercel/Railway
- **Database**: Read replicas for heavy loads
- **Caching**: Redis for session/hot data
- **CDN**: Cloudflare global network
- **Media**: Separate storage service
- **Load Balancing**: Automatic via platforms

## Bot Prevention & Content Moderation

### Multi-Layer Bot Prevention
1. **Email Verification**: Mandatory before access
2. **Phone Verification**: Optional for premium tier
3. **Profile Photo**: Required, AI-verified for real face
4. **Behavioral Analysis**: AI monitors usage patterns
5. **Rate Limiting**: Actions per minute/hour
6. **CAPTCHA**: On suspicious activity
7. **Device Fingerprinting**: Track unique devices
8. **IP Reputation**: Block known bot networks (Cloudflare)
9. **Activity Monitoring**: Flag unusual patterns
10. **Human Verification**: Manual review for flagged accounts

### AI-Powered Moderation
```typescript
// Blaze AI content analysis
const moderateContent = async (content: string) => {
  const analysis = await blazeAI.moderate({
    text: content,
    categories: ['hate', 'harassment', 'violence', 'sexual', 'spam']
  });
  
  if (analysis.flagged) {
    // Auto-warn or remove content
    await handleViolation(analysis);
  }
};
```

### Content Moderation Features
- **Real-time Scanning**: All messages and media
- **Image Moderation**: Inappropriate image detection
- **Keyword Filtering**: Configurable word lists
- **Report System**: User-initiated reports
- **Appeal Process**: Contest false positives
- **Automated Actions**: Warn → Suspend → Ban
- **Human Review**: For edge cases

### Spam Prevention
- Limit messages to non-matches
- Group invite restrictions
- Link spam detection
- Mass messaging prevention
- New account limitations (48-hour probation)
- Verified badge system

### Account Trust Scoring
```typescript
interface TrustScore {
  score: number; // 0-100
  factors: {
    emailVerified: boolean;
    phoneVerified: boolean;
    profileComplete: boolean;
    accountAge: number; // days
    activityNormal: boolean;
    reportsReceived: number;
    reportsMade: number;
  };
}

// Low trust = limited features
// High trust = full access
```

## Code Quality Standards

### TypeScript
- Use strict mode
- Define interfaces for all data structures
- Avoid `any` type
- Use type guards for runtime checks

### Naming Conventions
- Components: PascalCase
- Functions: camelCase
- Constants: UPPER_SNAKE_CASE
- Files: kebab-case or PascalCase for components

### Comments
- Document complex logic
- Explain "why" not "what"
- Keep comments up to date
- Use JSDoc for functions

## Real-Time Features

### Supabase Realtime Subscriptions

#### Message Delivery
```typescript
// Subscribe to new messages in conversation
const subscription = supabase
  .channel(`messages:${conversationId}`)
  .on('postgres_changes', {
    event: 'INSERT',
    schema: 'public',
    table: 'messages',
    filter: `conversation_id=eq.${conversationId}`
  }, (payload) => {
    handleNewMessage(payload.new);
  })
  .subscribe();

// Clean up on unmount
return () => subscription.unsubscribe();
```

#### Typing Indicators
```typescript
// Broadcast typing status
const channel = supabase.channel(`typing:${conversationId}`);

const startTyping = () => {
  channel.send({
    type: 'broadcast',
    event: 'typing',
    payload: { userId: currentUser.id, isTyping: true }
  });
};

const stopTyping = () => {
  channel.send({
    type: 'broadcast',
    event: 'typing',
    payload: { userId: currentUser.id, isTyping: false }
  });
};
```

#### Presence System
```typescript
// Track online users
const presence = supabase.channel('online-users');

presence
  .on('presence', { event: 'sync' }, () => {
    const users = presence.presenceState();
    updateOnlineUsers(users);
  })
  .on('presence', { event: 'join' }, ({ key, newPresences }) => {
    handleUserJoined(newPresences);
  })
  .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
    handleUserLeft(leftPresences);
  })
  .subscribe(async (status) => {
    if (status === 'SUBSCRIBED') {
      await presence.track({
        user_id: currentUser.id,
        online_at: new Date().toISOString()
      });
    }
  });
```

#### Delivery Status
- **Sent**: Message stored in database
- **Delivered**: Recipient's device received message
- **Read**: Recipient viewed message
- **Failed**: Network error or blocked user

#### Connection Management
- Auto-reconnect on network loss
- Exponential backoff retry logic
- Connection state indicators in UI
- Queue messages when offline
- Sync when connection restored

### WebSocket for Video Calls
- Signaling for WebRTC connections
- ICE candidate exchange
- Call state management
- Participant join/leave events
- Network quality updates

## API Route Patterns

### Standard Structure
```typescript
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { NextResponse } from 'next/server';
import { z } from 'zod';

export async function POST(request: Request) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    
    // 1. Verify authentication
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' }, 
        { status: 401 }
      );
    }
    
    // 2. Validate input
    const body = await request.json();
    const schema = z.object({
      // Define schema
    });
    const validated = schema.parse(body);
    
    // 3. Check rate limits
    const rateLimitOk = await checkRateLimit(session.user.id);
    if (!rateLimitOk) {
      return NextResponse.json(
        { error: 'Rate limit exceeded' },
        { status: 429 }
      );
    }
    
    // 4. Process request
    const result = await processRequest(validated);
    
    // 5. Return response
    return NextResponse.json({ data: result });
    
  } catch (error) {
    console.error('API Error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Key API Routes

#### Messaging
- `POST /api/messages` - Send message
- `GET /api/messages/[id]` - Get conversation
- `PATCH /api/messages/[id]` - Mark as read
- `DELETE /api/messages/[id]` - Delete message

#### Video Calls
- `POST /api/video/initiate` - Start call
- `POST /api/video/signal` - WebRTC signaling
- `POST /api/video/end` - End call
- `GET /api/video/history` - Call history

#### Groups
- `POST /api/groups` - Create group
- `PATCH /api/groups/[id]` - Update group
- `POST /api/groups/[id]/members` - Add member
- `DELETE /api/groups/[id]/members/[userId]` - Remove member

#### Files
- `POST /api/files/upload` - Upload file
- `GET /api/files/[id]` - Download file
- `DELETE /api/files/[id]` - Delete file

#### AI (Blaze AI)
- `POST /api/ai/suggest` - Get suggestions
- `POST /api/ai/translate` - Translate message
- `POST /api/ai/moderate` - Moderate content
- `POST /api/ai/transcribe` - Voice-to-text

#### Migration
- `POST /api/migration/telegram/auth` - Authenticate with Telegram
- `POST /api/migration/telegram/import` - Start import
- `GET /api/migration/telegram/status` - Check progress

#### Payments
- `POST /api/payments/checkout` - Create checkout session
- `POST /api/payments/webhook` - Stripe webhook
- `GET /api/payments/subscription` - Get subscription status

## Development Workflow

### When Starting a Task
1. Understand the user story/requirement
2. Check existing code and patterns
3. Plan the implementation approach
4. Consider security implications
5. Write code following these rules
6. Test thoroughly
7. Handle errors gracefully

### Before Committing
- Test authentication flow
- Verify RLS policies
- Check mobile responsiveness
- Validate error handling
- Review for hardcoded values
- Ensure environment variables used

## Common Pitfalls to Avoid

### Security
1. **RLS Policies**: Never skip on new tables - default deny, explicit allow
2. **Auth Checks**: Always verify session on protected routes
3. **API Keys**: Never expose service keys or Perplexity API key to client
4. **Input Validation**: Validate AND sanitize all user inputs
5. **Rate Limiting**: Implement on all user-facing APIs
6. **File Uploads**: Always scan for malware and validate types

### Performance
7. **Real-time Subscriptions**: Clean up to prevent memory leaks
8. **Images**: Always optimize and use Next.js Image component
9. **Bundle Size**: Keep under 200kb initial load
10. **Database Queries**: Avoid N+1 queries, use joins and indexes
11. **WebRTC**: Close peer connections properly
12. **Caching**: Implement for frequently accessed data

### Code Quality
13. **Client/Server**: Don't use server-only code in client components
14. **Error Messages**: Don't show technical errors to users
15. **TypeScript**: Avoid `any` type, use strict mode
16. **Console Logs**: Remove debug logs before production
17. **Hard-coded Values**: Use environment variables

### User Experience
18. **Loading States**: Always show for async operations
19. **Error Handling**: Provide actionable error messages
20. **Offline Mode**: Handle network failures gracefully
21. **Mobile**: Test on real devices, not just browser
22. **Accessibility**: Use semantic HTML and ARIA labels

### WebRTC
23. **Permissions**: Request camera/mic with clear explanation
24. **Cleanup**: Always stop media streams when done
25. **Fallback**: Handle browsers without WebRTC support
26. **Network**: Implement TURN servers for NAT traversal

### AI Integration
27. **Cost Management**: Track AI API usage and costs
28. **Rate Limits**: Respect Perplexity API limits
29. **Fallbacks**: Handle AI service downtime gracefully
30. **Privacy**: Don't send sensitive data to AI unnecessarily

### Migration
31. **Data Validation**: Verify imported Telegram data integrity
32. **User Consent**: Always get explicit permission
33. **Error Recovery**: Handle partial migration failures
34. **Rate Limits**: Respect Telegram API limits

## Success Metrics & KPIs

### User Acquisition
- Daily Active Users (DAU)
- Monthly Active Users (MAU)
- User signup completion rate
- Email verification rate
- Profile completion rate
- Retention rate (D1, D7, D30)
- Churn rate

### Engagement Metrics
- Messages sent per user per day
- Video call minutes per user
- Files shared per user
- Group creation rate
- Average session duration
- Time spent in app
- Feature adoption rates

### Social Discovery
- Match success rate
- Conversation initiation rate
- Response rate to first message
- Match-to-conversation conversion
- Profile view to match ratio

### AI Features (Blaze AI)
- AI suggestion acceptance rate
- Translation usage frequency
- AI moderation accuracy
- Voice transcription usage
- Profile optimization completions

### Monetization
- Free to Premium conversion rate
- Monthly Recurring Revenue (MRR)
- Average Revenue Per User (ARPU)
- Customer Lifetime Value (LTV)
- Churn rate by tier
- Payment success rate

### Migration (Telegram)
- Migration initiation rate
- Migration completion rate
- Average time to migrate
- Chats imported per user
- User retention post-migration

### Technical Performance
- App load time (< 3 seconds)
- API response time (< 200ms p95)
- Video call connection success rate (> 95%)
- Message delivery rate (> 99.9%)
- Uptime (99.9% SLA)
- Error rate (< 0.1%)

### Safety & Moderation
- Reports processed per day
- False positive rate (< 5%)
- Response time to critical reports
- Bot account detection rate
- Content violation rate
- Appeal resolution time

## Community Guidelines & Content Policy

### Core Principles
- **Respect**: Treat all users with dignity and respect
- **Safety**: Platform is a safe space for authentic connection
- **Authenticity**: Be genuine, no fake profiles or bots
- **Privacy**: Respect others' privacy and boundaries
- **Consent**: All interactions require mutual consent
- **Inclusivity**: Welcome users of all backgrounds

### Prohibited Content
- Hate speech, racism, discrimination
- Harassment, bullying, threats
- Sexual content without consent
- Child endangerment (zero tolerance)
- Violence or self-harm promotion
- Spam or commercial solicitation
- Impersonation or fake profiles
- Illegal activities
- Misinformation or fraud

### Enforcement Actions
1. **Warning**: First offense for minor violations
2. **Temporary Ban**: 24-72 hours for repeat violations
3. **Permanent Ban**: Severe violations or repeated offenses
4. **Content Removal**: Immediate for policy violations
5. **Feature Restrictions**: Limit capabilities for probation

### User Reporting
- One-tap report from any message/profile
- Categories: Harassment, spam, inappropriate content, fake profile
- Optional details and evidence
- Anonymous reporting
- Status updates on reports
- Appeal process for false reports

### AI-Assisted Moderation
- Real-time content scanning (Blaze AI)
- Proactive threat detection
- Pattern recognition for serial violators
- Automated warnings for borderline content
- Human review for complex cases
- Continuous learning from decisions

### Age Verification
- 18+ required (non-negotiable)
- Multiple verification methods
- AI-powered age estimation from photos
- Document verification for disputes
- Regular re-verification for suspicious accounts

---

## Development Workflow Best Practices

### Before Starting a Task
1. **Understand Requirements**: Read user story thoroughly
2. **Check Existing Code**: Review similar implementations
3. **Plan Architecture**: Consider scalability and security
4. **Review These Rules**: Ensure compliance with standards
5. **Set Up Environment**: Verify all services are running

### During Development
1. **Write Tests First**: TDD for critical features
2. **Security First**: Consider attack vectors
3. **Performance Aware**: Monitor bundle size and queries
4. **Accessibility**: Semantic HTML, ARIA labels
5. **Mobile Responsive**: Test on multiple viewports
6. **Error Handling**: Comprehensive try-catch blocks

### Before Committing
- [ ] Tests passing (unit + integration)
- [ ] RLS policies verified
- [ ] No console.logs or debug code
- [ ] TypeScript errors resolved
- [ ] Mobile responsiveness checked
- [ ] Error handling implemented
- [ ] Environment variables used (no hard-coded)
- [ ] Code formatted (Prettier)
- [ ] Linting passed (ESLint)
- [ ] Performance benchmarks met
- [ ] Accessibility tested
- [ ] Security review completed

### Code Review Checklist
- [ ] Logic is clear and maintainable
- [ ] Security vulnerabilities addressed
- [ ] Performance considerations met
- [ ] Error handling comprehensive
- [ ] Tests cover edge cases
- [ ] Documentation updated
- [ ] Breaking changes noted
- [ ] Database migrations tested

---

## Quick Reference

### Development Commands
```bash
npm run dev              # Start development server
npm run build            # Build for production
npm run start            # Start production server
npm run lint             # Run ESLint
npm run test             # Run tests
npm run test:e2e         # Run E2E tests
```

### Supabase Commands
```bash
npx supabase start       # Start local Supabase
npx supabase db push     # Push schema changes
npx supabase db reset    # Reset database
npx supabase gen types typescript --local > types/supabase.ts
```

### Deployment
```bash
vercel --prod            # Deploy to production
vercel env pull          # Pull environment variables
```

---

## Critical Reminders

### 🔐 Security is Paramount
- Every table needs RLS policies
- Never expose service keys to client
- Validate and sanitize ALL inputs
- Implement rate limiting everywhere
- Encrypt sensitive data

### ⚡ Performance Matters
- Keep bundle size < 200kb
- Optimize images automatically
- Clean up subscriptions
- Implement caching strategies
- Monitor real-time connection counts

### 🤖 AI Integration (Blaze AI)
- Always display "Blaze AI powered by Perplexity"
- Track API usage and costs
- Implement fallbacks for downtime
- Respect rate limits
- Don't send unnecessary data to AI

### 🔄 Migration Excellence
- User-initiated only
- Transparent about data usage
- Verify data integrity
- Handle partial failures
- Comply with data portability laws

### 👥 User Experience First
- Mobile-first design approach
- Accessibility is not optional
- Clear error messages
- Loading states for everything
- Offline mode considerations

### 📊 Metrics-Driven Decisions
- Track all key metrics
- A/B test major changes
- Monitor error rates
- Analyze user feedback
- Iterate based on data

---

**Philosophy**: SLTR is building the future of social connection. Every line of code should reflect our commitment to privacy, security, performance, and exceptional user experience. We're not just building an app - we're creating a platform that respects users, protects their data, and delivers real value.

**"RULES DON'T APPLY"** - We're breaking the mold of traditional social platforms. Be innovative, but never compromise on security or user trust.
