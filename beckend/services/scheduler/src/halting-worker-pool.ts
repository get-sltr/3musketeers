import { Logger } from 'winston';\nimport { createLogger } from '../../shared/utils/logger';\nimport { ErosAnalysisQueue, AnalysisStatus } from '../../shared/types/eros.types';\nimport { ActivityTracker } from '../../shared/services/activity-tracker';\n\nexport interface WorkerJob {\n  jobId: string;\n  userId: string;\n  phase: 'phase1' | 'phase2' | 'phase3';\n  startedAt: Date;\n  abortController: AbortController;\n  isRunning: boolean;\n}\n\nexport class HaltingWorkerPool {\n  private workers: Map<string, WorkerJob> = new Map();\n  private logger: Logger;\n  private activityTracker: ActivityTracker;\n  private maxWorkers: number;\n  private cpuUsageByPhase: {\n    phase1: number; // 5%\n    phase2: number; // 15%\n    phase3: number; // 100%\n  };\n\n  constructor(activityTracker: ActivityTracker, maxWorkers: number = 10) {\n    this.logger = createLogger('HaltingWorkerPool');\n    this.activityTracker = activityTracker;\n    this.maxWorkers = maxWorkers;\n    this.cpuUsageByPhase = {\n      phase1: 5,\n      phase2: 15,\n      phase3: 100\n    };\n\n    // Monitor for user activity and halt jobs if needed\n    this.startActivityMonitor();\n  }\n\n  /**\n   * Submit a job to the worker pool\n   */\n  public async submitJob(\n    jobId: string,\n    userId: string,\n    phase: 'phase1' | 'phase2' | 'phase3',\n    processor: (signal: AbortSignal) => Promise<void>\n  ): Promise<void> {\n    // Wait for available worker slot\n    while (this.workers.size >= this.maxWorkers) {\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    const abortController = new AbortController();\n    const workerJob: WorkerJob = {\n      jobId,\n      userId,\n      phase,\n      startedAt: new Date(),\n      abortController,\n      isRunning: true\n    };\n\n    this.workers.set(jobId, workerJob);\n    this.logger.debug('Job submitted', { jobId, userId, phase, workersActive: this.workers.size });\n\n    try {\n      // Run job with abort capability\n      await processor(abortController.signal);\n      this.logger.info('Job completed', { jobId, userId, phase });\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        this.logger.info('Job halted', { jobId, userId, reason: 'user_became_active' });\n      } else {\n        this.logger.error('Job failed', {\n          jobId,\n          userId,\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n    } finally {\n      workerJob.isRunning = false;\n      this.workers.delete(jobId);\n    }\n  }\n\n  /**\n   * Get estimated CPU usage based on current load\n   */\n  public getEstimatedCPUUsage(): number {\n    let totalUsage = 0;\n\n    for (const job of this.workers.values()) {\n      totalUsage += this.cpuUsageByPhase[job.phase];\n    }\n\n    return Math.min(100, totalUsage);\n  }\n\n  /**\n   * Check if can accept more jobs (CPU headroom)\n   */\n  public canAcceptJob(phase: 'phase1' | 'phase2' | 'phase3'): boolean {\n    const currentUsage = this.getEstimatedCPUUsage();\n    const additionalUsage = this.cpuUsageByPhase[phase];\n\n    return currentUsage + additionalUsage <= 95; // Keep 5% headroom\n  }\n\n  /**\n   * Get worker count by phase\n   */\n  public getWorkersByPhase(): {\n    phase1: number;\n    phase2: number;\n    phase3: number;\n  } {\n    let phase1 = 0;\n    let phase2 = 0;\n    let phase3 = 0;\n\n    for (const job of this.workers.values()) {\n      switch (job.phase) {\n        case 'phase1':\n          phase1++;\n          break;\n        case 'phase2':\n          phase2++;\n          break;\n        case 'phase3':\n          phase3++;\n          break;\n      }\n    }\n\n    return { phase1, phase2, phase3 };\n  }\n\n  /**\n   * Get worker stats\n   */\n  public getStats(): {\n    activeWorkers: number;\n    maxWorkers: number;\n    cpuUsage: number;\n    phase1Count: number;\n    phase2Count: number;\n    phase3Count: number;\n    averageJobDuration: number;\n  } {\n    const phases = this.getWorkersByPhase();\n    let totalDuration = 0;\n    let jobCount = 0;\n\n    for (const job of this.workers.values()) {\n      const duration = Date.now() - job.startedAt.getTime();\n      totalDuration += duration;\n      jobCount++;\n    }\n\n    return {\n      activeWorkers: this.workers.size,\n      maxWorkers: this.maxWorkers,\n      cpuUsage: this.getEstimatedCPUUsage(),\n      phase1Count: phases.phase1,\n      phase2Count: phases.phase2,\n      phase3Count: phases.phase3,\n      averageJobDuration: jobCount > 0 ? totalDuration / jobCount : 0\n    };\n  }\n\n  /**\n   * Monitor for user activity and halt jobs if needed\n   */\n  private startActivityMonitor(): void {\n    setInterval(() => {\n      // Check each active job\n      for (const [jobId, job] of this.workers) {\n        // Check if user just became active\n        if (this.activityTracker.didUserBecomeActive(job.userId)) {\n          this.logger.info('User became active, halting job', { jobId, userId: job.userId });\n          job.abortController.abort();\n        }\n      }\n    }, 500); // Check every 500ms for responsiveness\n  }\n\n  /**\n   * Gracefully shutdown worker pool\n   */\n  public async shutdown(): Promise<void> {\n    this.logger.info('Shutting down worker pool', { activeJobs: this.workers.size });\n\n    // Halt all running jobs\n    for (const [jobId, job] of this.workers) {\n      if (job.isRunning) {\n        this.logger.debug('Halting job during shutdown', { jobId });\n        job.abortController.abort();\n      }\n    }\n\n    // Wait for jobs to complete (max 5 seconds)\n    const startTime = Date.now();\n    while (this.workers.size > 0 && Date.now() - startTime < 5000) {\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    this.logger.info('Worker pool shutdown complete', { remainingJobs: this.workers.size });\n  }\n}\n\n/**\n * Singleton instance\n */\nlet instance: HaltingWorkerPool | null = null;\n\nexport function initWorkerPool(activityTracker: ActivityTracker, maxWorkers?: number): HaltingWorkerPool {\n  instance = new HaltingWorkerPool(activityTracker, maxWorkers);\n  return instance;\n}\n\nexport function getWorkerPool(): HaltingWorkerPool {\n  if (!instance) {\n    throw new Error('HaltingWorkerPool not initialized. Call initWorkerPool first.');\n  }\n  return instance;\n}\n