import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { Logger } from 'winston';\nimport { createLogger } from '../../shared/utils/logger';\nimport { DatabaseClient } from '../../shared/database/client';\nimport { CacheManager } from '../../shared/services/cache-manager';\nimport { ActivityTracker } from '../../shared/services/activity-tracker';\n\nexport class MatchesRoutes {\n  private logger: Logger;\n  private db: DatabaseClient;\n  private cache: CacheManager;\n  private activityTracker: ActivityTracker;\n\n  constructor(db: DatabaseClient, cache: CacheManager, activityTracker: ActivityTracker) {\n    this.logger = createLogger('MatchesRoutes');\n    this.db = db;\n    this.cache = cache;\n    this.activityTracker = activityTracker;\n  }\n\n  public registerRoutes(fastify: FastifyInstance, prefix: string): void {\n    // Get today's daily matches (cached)\n    fastify.get(`${prefix}/matches/daily`, async (request: FastifyRequest, reply: FastifyReply) => {\n      return this.getDailyMatches(request, reply);\n    });\n\n    // Get matches for specific date\n    fastify.get(`${prefix}/matches/daily/:date`, async (request: FastifyRequest, reply: FastifyReply) => {\n      return this.getDailyMatchesByDate(request, reply);\n    });\n\n    // Get recommendations (cached)\n    fastify.get(`${prefix}/matches/recommendations`, async (request: FastifyRequest, reply: FastifyReply) => {\n      return this.getRecommendations(request, reply);\n    });\n\n    // Record user action (like, skip, etc.)\n    fastify.post(`${prefix}/matches/:matchId/action`, async (request: FastifyRequest, reply: FastifyReply) => {\n      return this.recordAction(request, reply);\n    });\n\n    this.logger.info('Matches routes registered');\n  }\n\n  private async getDailyMatches(request: FastifyRequest, reply: FastifyReply): Promise<any> {\n    try {\n      if (!request.user) {\n        reply.code(401);\n        return { success: false, error: 'Unauthorized' };\n      }\n\n      const userId = (request.user as any).userId || (request.user as any).sub;\n      const today = new Date().toISOString().split('T')[0];\n\n      // Try cache first\n      const cached = await this.cache.getDailyMatches(userId);\n      if (cached) {\n        this.logger.debug('Daily matches cache hit', { userId });\n        return {\n          success: true,\n          matches: cached,\n          source: 'cache',\n          date: today\n        };\n      }\n\n      // Get from database\n      const { data: matches, error } = await this.db.getClient()\n        .from('eros_daily_matches')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('match_date', today)\n        .order('rank', { ascending: true });\n\n      if (error) {\n        this.logger.error('Get daily matches error', { userId, error: error.message });\n        reply.code(500);\n        return { success: false, error: 'Failed to fetch matches' };\n      }\n\n      // Cache results\n      if (matches && matches.length > 0) {\n        await this.cache.setDailyMatches(userId, matches);\n      }\n\n      // Record activity\n      this.activityTracker.recordActivity(userId);\n\n      return {\n        success: true,\n        matches: matches || [],\n        source: 'database',\n        count: matches?.length || 0,\n        date: today\n      };\n    } catch (error) {\n      this.logger.error('Get daily matches error', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      reply.code(500);\n      return { success: false, error: 'Failed to fetch matches' };\n    }\n  }\n\n  private async getDailyMatchesByDate(request: FastifyRequest, reply: FastifyReply): Promise<any> {\n    try {\n      if (!request.user) {\n        reply.code(401);\n        return { success: false, error: 'Unauthorized' };\n      }\n\n      const userId = (request.user as any).userId || (request.user as any).sub;\n      const date = (request.params as any).date;\n\n      // Validate date format\n      if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(date)) {\n        reply.code(400);\n        return { success: false, error: 'Invalid date format (use YYYY-MM-DD)' };\n      }\n\n      // Get from database\n      const { data: matches, error } = await this.db.getClient()\n        .from('eros_daily_matches')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('match_date', date)\n        .order('rank', { ascending: true });\n\n      if (error) {\n        reply.code(500);\n        return { success: false, error: 'Failed to fetch matches' };\n      }\n\n      return {\n        success: true,\n        matches: matches || [],\n        count: matches?.length || 0,\n        date\n      };\n    } catch (error) {\n      this.logger.error('Get matches by date error', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      reply.code(500);\n      return { success: false, error: 'Failed to fetch matches' };\n    }\n  }\n\n  private async getRecommendations(request: FastifyRequest, reply: FastifyReply): Promise<any> {\n    try {\n      if (!request.user) {\n        reply.code(401);\n        return { success: false, error: 'Unauthorized' };\n      }\n\n      const userId = (request.user as any).userId || (request.user as any).sub;\n      const limit = (request.query as any).limit || 10;\n\n      // Try cache\n      const cached = await this.cache.getRecommendations(userId);\n      if (cached) {\n        this.logger.debug('Recommendations cache hit', { userId });\n        return {\n          success: true,\n          recommendations: cached.slice(0, limit),\n          source: 'cache'\n        };\n      }\n\n      // Get from database (match scores)\n      const { data: scores, error } = await this.db.getClient()\n        .from('eros_match_scores')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('is_valid', true)\n        .gt('expires_at', new Date().toISOString())\n        .order('compatibility_score', { ascending: false })\n        .limit(limit);\n\n      if (error) {\n        reply.code(500);\n        return { success: false, error: 'Failed to fetch recommendations' };\n      }\n\n      // Cache results\n      if (scores && scores.length > 0) {\n        await this.cache.setRecommendations(userId, scores);\n      }\n\n      return {\n        success: true,\n        recommendations: scores || [],\n        source: 'database',\n        count: scores?.length || 0\n      };\n    } catch (error) {\n      this.logger.error('Get recommendations error', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      reply.code(500);\n      return { success: false, error: 'Failed to fetch recommendations' };\n    }\n  }\n\n  private async recordAction(request: FastifyRequest, reply: FastifyReply): Promise<any> {\n    try {\n      if (!request.user) {\n        reply.code(401);\n        return { success: false, error: 'Unauthorized' };\n      }\n\n      const userId = (request.user as any).userId || (request.user as any).sub;\n      const matchId = (request.params as any).matchId;\n      const { action } = request.body as { action: 'like' | 'skip' | 'view' | 'report' };\n\n      if (!['like', 'skip', 'view', 'report'].includes(action)) {\n        reply.code(400);\n        return { success: false, error: 'Invalid action' };\n      }\n\n      // Record action in database\n      const { error } = await this.db.getClient()\n        .from('eros_daily_matches')\n        .update({\n          action_taken: action,\n          action_taken_at: new Date()\n        })\n        .eq('id', matchId)\n        .eq('user_id', userId);\n\n      if (error) {\n        this.logger.error('Record action error', { matchId, userId, error: error.message });\n        reply.code(500);\n        return { success: false, error: 'Failed to record action' };\n      }\n\n      // Record activity (for inactivity tracking)\n      this.activityTracker.recordActivity(userId);\n\n      this.logger.debug('Action recorded', { userId, matchId, action });\n\n      return {\n        success: true,\n        message: `Action '${action}' recorded successfully`\n      };\n    } catch (error) {\n      this.logger.error('Record action error', {\n        error: error instanceof Error ? error.message : String(error)\n      });\n      reply.code(500);\n      return { success: false, error: 'Failed to record action' };\n    }\n  }\n}\n